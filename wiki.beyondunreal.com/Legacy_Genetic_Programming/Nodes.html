<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">

<!-- Mirrored from wiki.beyondunreal.com/Legacy:Genetic_Programming/Nodes by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 16 Dec 2016 09:41:30 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8" />
<title>Legacy:Genetic Programming/Nodes - Unreal Wiki</title>
<meta name="generator" content="MediaWiki 1.25.1" />
<link rel="alternate" type="application/x-wiki" title="Edit" href="https://wiki.beyondunreal.com/edit/Legacy:Genetic_Programming/Nodes" />
<link rel="edit" title="Edit" href="https://wiki.beyondunreal.com/edit/Legacy:Genetic_Programming/Nodes" />
<link rel="shortcut icon" href="../w/uewiki-favicon.png" />
<link rel="search" type="application/opensearchdescription+xml" href="../w/opensearch_desc.php" title="Unreal Wiki" />
<link rel="EditURI" type="application/rsd+xml" href="../w/api251f.php?action=rsd" />
<link rel="alternate" hreflang="x-default" href="Nodes.html" />
<link rel="copyright" href="../Unreal_Wiki_Copyrights.html" />
<link rel="alternate" type="application/atom+xml" title="Unreal Wiki Atom feed" href="https://wiki.beyondunreal.com/Special:RecentChanges?feed=atom" />
<link rel="stylesheet" href="../w/load2743.css?debug=false&amp;lang=en&amp;modules=ext.geshi.language.uscript%7Cmediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.content.externallinks%7Cmediawiki.skinning.interface%7Cmediawiki.ui.button%7Cskins.monobook.styles&amp;only=styles&amp;skin=monobook&amp;*" />
<!--[if IE 6]><link rel="stylesheet" href="/w/skins/MonoBook/IE60Fixes.css?303" media="screen" /><![endif]-->
<!--[if IE 7]><link rel="stylesheet" href="/w/skins/MonoBook/IE70Fixes.css?303" media="screen" /><![endif]--><meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="../w/load484a.css?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=monobook&amp;*" />
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: wiki:resourceloader:filter:minify-css:7:29b70323345a439ab9ed7007e0c178a6 */</style>
<script src="../w/load9316.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=monobook&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"Legacy","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":100,"wgPageName":"Legacy:Genetic_Programming/Nodes","wgTitle":"Genetic Programming/Nodes","wgCurRevisionId":3460,"wgRevisionId":3460,"wgArticleId":1363,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Legacy:Genetic_Programming/Nodes","wgRelevantArticleId":1363,"wgIsProbablyEditable":true,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgCategoryTreePageCategoryOptions":"{\"mode\":0,\"hideprefix\":20,\"showcount\":true,\"namespaces\":false}"});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($,jQuery){mw.user.options.set({"variant":"en"});});mw.loader.implement("user.tokens",function($,jQuery){mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\"});});
/* cache key: wiki:resourceloader:filter:minify-js:7:a5c52c063dc436c1ca7c9f456936a5e9 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax"]);
}</script>
</head>
<body class="mediawiki ltr sitedir-ltr ns-100 ns-subject page-Legacy_Genetic_Programming_Nodes skin-monobook action-view">
<div id="globalWrapper">
		<div id="column-content">
			<div id="content" class="mw-body" role="main">
				<a id="top"></a>
									<div id="siteNotice"><div id="localNotice" lang="en" dir="ltr"><p>Mostly Harmless
</p></div></div>
				<div class="mw-indicators">
</div>
				<h1 id="firstHeading" class="firstHeading" lang="en">Legacy:Genetic Programming/Nodes</h1>

				<div id="bodyContent" class="mw-body-content">
					<div id="siteSub">From Unreal Wiki, The Unreal Engine Documentation Site</div>
					<div id="contentSub"><span class="subpages">&lt; <a href="../Legacy_Genetic_Programming.html" title="Legacy:Genetic Programming">Legacy:Genetic Programming</a></span></div>
										<div id="jump-to-nav" class="mw-jump">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>

					<!-- start content -->
					<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><p>First off, read the introduction on <a href="../Legacy_Genetic_Programming.html" title="Legacy:Genetic Programming">Genetic Programming</a>, and go look at the animated tutorial at <a rel="nofollow" class="external text" href="http://www.genetic-programming.com/gpanimatedtutorial.html">www.genetic-programming.com/gpanimatedtutorial.html</a> or all of this is all going to be nonsense&#160;:)</p>
<p>OK, by now you should know that GP uses a tree structure of linked objects to do its 'thinking' these objects are either 'Terminals' (i.e. 'leaves' at the end of the tree branches which return either sensor input or constant values) or 'Functions' which take one or more values and return another.</p>
<p>In my implimentation all nodes take and return floats as arguments so it doesn't matter how much you mix things up, no node gets presented with data it can't cope with.</p>
<p>Here's a simple node that adds together its two inputs:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="uscript source-uscript">
<pre class="de1">
<span class="co1">//-----------------------------------------------------------</span>
<span class="co1">// arithmetic addition function</span>
<span class="co1">//-----------------------------------------------------------</span>
<span class="kw1">class</span> GPFplus <span class="kw1">extends</span> GPnode;
 
 
<span class="kw1">function</span> <span class="kw5">float</span> evaluate<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw2">return</span><span class="br0">(</span> children<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span>.<span class="me0">evaluate</span><span class="br0">(</span><span class="br0">)</span> <span class="sy0">+</span> children<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span>.<span class="me0">evaluate</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>;
<span class="br0">}</span>
 
<span class="kw1">function</span> <span class="kw5">string</span> makemytoken<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw2">return</span><span class="br0">(</span><span class="st0">"+"</span><span class="br0">)</span>;
<span class="br0">}</span>
 
 
<span class="kw1">DefaultProperties</span>
<span class="br0">{</span>
 childcount<span class="sy0">=</span><span class="nu0">2</span>
<span class="br0">}</span>
</pre></div>
</div>
<p>It extends GPnode which is the base class of all the nodes and includes lots of baggage to be explained later, for now just notice that the nodes below it in the parse tree are referenced by the children[] array and that the evaluate method is called on these children in order to get the values that need to be added together. This is the basic magic, all the objects in the tree are linked together and control flows down the branches until something that actually returns a value is evaluated. Some nodes are conditional and branches get evaluated or not depending on conditions... in this way we can produce a program that actually varies its behavior according to conditions, unlike any of the simple examples in the tutorial linked to above which are more like equations than anything we'd call 'code'.</p>
<p>As an example here's evaluate for the 'less than' node:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="uscript source-uscript">
<pre class="de1">
<span class="kw1">function</span> <span class="kw5">float</span> evaluate<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw1">local</span> <span class="kw5">float</span> arg1,arg2;
  arg1<span class="sy0">=</span>children<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span>.<span class="me0">evaluate</span><span class="br0">(</span><span class="br0">)</span>;
  arg2<span class="sy0">=</span>children<span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span>.<span class="me0">evaluate</span><span class="br0">(</span><span class="br0">)</span>;
  <span class="kw2">if</span><span class="br0">(</span>arg1<span class="sy0">&lt;</span>arg2<span class="br0">)</span> <span class="kw2">return</span><span class="br0">(</span>children<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span>.<span class="me0">evaluate</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>;
  <span class="kw2">else</span>
    <span class="kw2">return</span><span class="br0">(</span>children<span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span>.<span class="me0">evaluate</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>;
<span class="br0">}</span>
</pre></div>
</div>
<p>Notice how sometimes children[2] gets evaluated and other times it's children[3] that gets to see some action.</p>
<p>Now in order to get any of this to work we need a way of storing the tree so it can be passed around and manipulated, this is where makemytoken() comes in, its job is to return the string representation of that node... pretty simple here but nodes which hold values need something more... here's evaluate and makemytoken for the 'constant' terminal node:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="uscript source-uscript">
<pre class="de1">
<span class="kw1">var</span> <span class="kw5">float</span> val;
 
<span class="kw1">function</span> <span class="kw5">float</span> evaluate<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw2">return</span><span class="br0">(</span>val<span class="br0">)</span>;
<span class="br0">}</span>
 
<span class="kw1">function</span> <span class="kw5">string</span> makemytoken<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw2">return</span><span class="br0">(</span><span class="st0">"K"</span><span class="sy0">$</span>val<span class="br0">)</span>;
<span class="br0">}</span>
</pre></div>
</div>
<p>As you can see I use the character K to flag a constant and then append the value to is using uscripts really rather useful built in type conversions.</p>
<p>Enough specifics, I hope that conveys the gist, here's the core GPnode code in it's glory:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="uscript source-uscript">
<pre class="de1">
<span class="co1">//-----------------------------------------------------------</span>
<span class="co1">// Genetic Programming parse tree node root class</span>
<span class="co1">//-----------------------------------------------------------</span>
<span class="kw1">class</span> GPnode <span class="kw1">extends</span> <span class="kw9">Actor</span>;
 
 
<span class="kw1">Var</span> <span class="kw5">int</span> Childcount;
<span class="kw1">var</span> GPnode children<span class="br0">[</span><span class="nu0">4</span><span class="br0">]</span>, parent;
<span class="kw1">var</span> <span class="kw5">int</span> childnum, depth; <span class="co1">// self = parent.chilren[childnum]</span>
<span class="kw1">var</span> <span class="kw5">string</span> mytoken;
<span class="kw1">var</span> <span class="kw9">actor</span> mypawn;            <span class="co1">// might not be always be a pawn, hence type = actor for now</span>
<span class="kw1">var</span> <span class="kw1">const</span> <span class="kw5">string</span> terminators, functions;
<span class="kw1">var</span> <span class="kw1">const</span> <span class="kw5">string</span> alltypes;
 
 
<span class="kw1">function</span> <span class="kw5">float</span> evaluate<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw2">return</span><span class="br0">(</span>children<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span>.<span class="me0">evaluate</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>;
<span class="br0">}</span>
</pre></div>
</div>
<p>Variables and a very empty evaluate method.</p>
<p>Now more recursion: this is how the tree gets written out as a string: the node writes it's own token to the string then calls writetostring on its children, those children in turn get their children to write a token to the string and so on... somehow satisfyingly cool to someone like myself who's never been beyond a simple recursive factiorial function before&#160;:)</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="uscript source-uscript">
<pre class="de1">
<span class="kw1">function</span> WriteToString<span class="br0">(</span> <span class="kw1">out</span> <span class="kw5">string</span> genome <span class="br0">)</span>
<span class="br0">{</span>
 <span class="kw1">local</span> <span class="kw5">int</span> i;
 genome <span class="sy0">=</span> genome<span class="sy0">$</span>MakeMyToken<span class="br0">(</span><span class="br0">)</span>;
 <span class="kw2">if</span><span class="br0">(</span>childcount <span class="sy0">==</span> <span class="nu0">0</span><span class="br0">)</span> <span class="kw2">return</span>;
 <span class="kw2">else</span>
  <span class="br0">{</span>
    <span class="kw2">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">0</span>;i<span class="sy0">&lt;</span>childcount;i<span class="sy0">++</span><span class="br0">)</span>
     <span class="br0">{</span>
       children<span class="br0">[</span>i<span class="br0">]</span>.<span class="me0">WriteToString</span><span class="br0">(</span>genome<span class="br0">)</span>;
     <span class="br0">}</span>
  <span class="br0">}</span>
<span class="br0">}</span>
 
<span class="kw1">function</span> <span class="kw5">string</span> makemytoken<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
<span class="co1">//log("makemytoken called on "$self);</span>
<span class="co1">// null token for base class, make this return the string that represents</span>
<span class="co1">// any subclass (mostly one char but constant terminators need to write out</span>
<span class="co1">// their value forinstance)</span>
<span class="kw2">return</span><span class="br0">(</span><span class="st0">""</span><span class="br0">)</span>;
<span class="br0">}</span>
</pre></div>
</div>
<p>Notice also cunning use of an 'out' declaration there so all that needs to be done to create the genome string is simply call WriteToString(s) on the root node of the tree and as if by magic, S gets an encoded version of the object tree written to it.. by now I'm really starting to grock recursion properly and feel like I'm on a run, the elegence of these objects all describing themselves is appealing but in the background I can't help wondering if it all might fall apart somehow...</p>
<p>Doubts or not, this is how most of the functionality has shaped up, simply call a method on the root node and all else follows for various tree manipulation tasks.</p>
<p>Now having written this string we neeed a way of reading it back in and creating an object tree out of it... so let's go all recursive again and we have the imaginatively named:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="uscript source-uscript">
<pre class="de1">
<span class="kw1">Function</span> ReadFromString<span class="br0">(</span> <span class="kw1">out</span> <span class="kw5">string</span> genome<span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw1">local</span> <span class="kw5">int</span> i;
  <span class="kw1">local</span> <span class="kw5">string</span> <span class="kw5">char</span>;
  <span class="kw1">local</span> GPnode node;
  <span class="kw2">for</span> <span class="br0">(</span> i <span class="sy0">=</span><span class="nu0">0</span>; i<span class="sy0">&lt;</span>childcount;i<span class="sy0">++</span><span class="br0">)</span>
  <span class="br0">{</span>
    <span class="co1">// eat and analyse first (leftmost) char of string</span>
 
    <span class="kw5">char</span> <span class="sy0">=</span> <span class="kw3">left</span><span class="br0">(</span>genome,<span class="nu0">1</span><span class="br0">)</span>;
    genome <span class="sy0">=</span> <span class="kw3">right</span><span class="br0">(</span>genome,<span class="kw3">len</span><span class="br0">(</span>genome<span class="br0">)</span><span class="sy0">-</span><span class="nu0">1</span><span class="br0">)</span>;
    node <span class="sy0">=</span> addchild<span class="br0">(</span> <span class="kw5">char</span>,i<span class="br0">)</span>;
    node.<span class="me0">ReadFromString</span><span class="br0">(</span>genome<span class="br0">)</span>;
 <span class="br0">}</span>
<span class="br0">}</span>
</pre></div>
</div>
<p>So basically you start by spawning a gpnode as the root, feed it the string of gobbledegook generated by writetostring and it reads (and discards) the first character, spawns the appropriate node actor, makes that its first child and passes the rest of the string to it so it can make any children it might need in turn... and so it goes on down the tree.</p>
<p>Addchild is a big switch that takes care of spawning the right sort of node type according to the character token that has been read in:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="uscript source-uscript">
<pre class="de1">
<span class="kw1">function</span> gpnode addchild<span class="br0">(</span><span class="kw5">string</span> childtype, <span class="kw5">int</span> i<span class="br0">)</span>
<span class="br0">{</span>
  <span class="kw1">local</span> class<span class="sy0">&lt;</span>actor<span class="sy0">&gt;</span>  child<span class="re0">class</span>&lt; SEMI &gt;
  <span class="kw1">local</span> gpnode node;
 
   <span class="kw2">switch</span><span class="br0">(</span>childtype<span class="br0">)</span>
   <span class="br0">{</span>
    <span class="co1">// functions first</span>
      <span class="kw2">case</span> <span class="st0">"+"</span>:
          childclass <span class="sy0">=</span> <span class="kw1">class</span><span class="st0">'GPFplus'</span>;
          <span class="kw2">break</span>;
      <span class="kw2">case</span> <span class="st0">"-"</span>:
          childclass <span class="sy0">=</span> <span class="kw1">class</span><span class="st0">'GPFminus'</span>;
          <span class="kw2">break</span>;
      <span class="kw2">case</span> <span class="st0">"*"</span>:
          childclass <span class="sy0">=</span> <span class="kw1">class</span><span class="st0">'GPFmultiply'</span>;
          <span class="kw2">break</span>;
      <span class="kw2">case</span> <span class="st0">"%"</span>:
          childclass <span class="sy0">=</span> <span class="kw1">class</span><span class="st0">'GPFsafeDivide'</span>;
          <span class="kw2">break</span>;
      <span class="kw2">case</span> <span class="st0">"&lt;"</span>:
          childclass <span class="sy0">=</span> <span class="kw1">class</span><span class="st0">'GPFlessThan'</span>;
          <span class="kw2">break</span>;
      <span class="kw2">case</span> <span class="st0">"Q"</span>:
          childclass <span class="sy0">=</span> <span class="kw1">class</span><span class="st0">'GPFSqrt'</span>;
          <span class="kw2">break</span>;
      <span class="kw2">case</span> <span class="st0">"N"</span>:
          childclass <span class="sy0">=</span> <span class="kw1">class</span><span class="st0">'GPFMin'</span>;
          <span class="kw2">break</span>;
      <span class="kw2">case</span> <span class="st0">"X"</span>:
          childclass <span class="sy0">=</span> <span class="kw1">class</span><span class="st0">'GPFMax'</span>;
          <span class="kw2">break</span>;
      <span class="co1">// then the terminators</span>
      <span class="kw2">case</span> <span class="st0">"R"</span>:
          childclass <span class="sy0">=</span> <span class="kw1">class</span><span class="st0">'GPFrightTurn'</span>;
          <span class="kw2">break</span>;
      <span class="kw2">case</span> <span class="st0">"L"</span>:
          childclass <span class="sy0">=</span> <span class="kw1">class</span><span class="st0">'GPFleftTurn'</span>;
          <span class="kw2">break</span>;
      <span class="kw2">case</span> <span class="st0">"K"</span>:
          childclass <span class="sy0">=</span> <span class="kw1">class</span><span class="st0">'GPTconstant'</span>;
          <span class="kw2">break</span>;
      <span class="kw2">case</span> <span class="st0">"A"</span>:
          childclass <span class="sy0">=</span> <span class="kw1">class</span><span class="st0">'GPTlookAhead'</span>;
          <span class="kw2">break</span>;
      <span class="kw2">case</span> <span class="st0">"B"</span>:
          childclass <span class="sy0">=</span> <span class="kw1">class</span><span class="st0">'GPTlookAheadRight'</span>;
          <span class="kw2">break</span>;
      <span class="kw2">case</span> <span class="st0">"C"</span>:
          childclass <span class="sy0">=</span> <span class="kw1">class</span><span class="st0">'GPTlookRight'</span>;
          <span class="kw2">break</span>;
      <span class="kw2">case</span> <span class="st0">"D"</span>:
          childclass <span class="sy0">=</span> <span class="kw1">class</span><span class="st0">'GPTlookBackRight'</span>;
          <span class="kw2">break</span>;
      <span class="kw2">case</span> <span class="st0">"E"</span>:
          childclass <span class="sy0">=</span> <span class="kw1">class</span><span class="st0">'GPTlookBack'</span>;
          <span class="kw2">break</span>;
      <span class="kw2">case</span> <span class="st0">"F"</span>:
          childclass <span class="sy0">=</span> <span class="kw1">class</span><span class="st0">'GPTlookBackLeft'</span>;
          <span class="kw2">break</span>;
      <span class="kw2">case</span> <span class="st0">"G"</span>:
          childclass <span class="sy0">=</span> <span class="kw1">class</span><span class="st0">'GPTlookLeft'</span>;
          <span class="kw2">break</span>;
      <span class="kw2">case</span> <span class="st0">"H"</span>:
          childclass <span class="sy0">=</span> <span class="kw1">class</span><span class="st0">'GPTlookAheadLeft'</span>;
          <span class="kw2">break</span>;
      <span class="kw1">default</span>:
          <span class="kw3">log</span><span class="br0">(</span> <span class="st0">" *gennode* Uh Oh! unknown token! "</span><span class="sy0">$</span>childtype<span class="br0">)</span>;
          <span class="kw2">break</span>;
    <span class="br0">}</span>
   <span class="co1">// log(" childclass = "$childclass);</span>
    node <span class="sy0">=</span> gpnode<span class="br0">(</span> <span class="kw4">spawn</span><span class="br0">(</span>childclass<span class="br0">)</span><span class="br0">)</span>;
    children<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">=</span>node;
    node.<span class="me0">mypawn</span> <span class="sy0">=</span> mypawn;
    node.<span class="me0">parent</span><span class="sy0">=</span><span class="kw6">self</span>;
    node.<span class="me0">childnum</span><span class="sy0">=</span>i;
    node.<span class="me0">depth</span><span class="sy0">=</span>depth<span class="sy0">+</span><span class="nu0">1</span>;
    <span class="kw2">return</span><span class="br0">(</span>node<span class="br0">)</span>;
<span class="br0">}</span>
</pre></div>
</div>
<p>... and the sands of time draw a close to the first session editing this page... things are already a lot clearer in my head thanks to explaining a little to you, dear reader... till the next time I leave you with the remainder of the gpnode class which deals with things like growing random sub trees and other housekeeping. You can view the rest of the classes so far on CVS at the home of UTron on sourcefore here: <a rel="nofollow" class="external autonumber" href="https://sourceforge.net/projects/utron/">[1]</a> click on 'browse CVS' and look for classes in the package 'UTron' with names beginning with GP.</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="uscript source-uscript">
<pre class="de1">
<span class="kw1">function</span> RandomGrow <span class="br0">(</span> <span class="kw5">int</span> depth, <span class="kw5">int</span> maxdepth <span class="br0">)</span>
<span class="br0">{</span>
<span class="kw1">local</span> <span class="kw5">int</span> i,j,r;
<span class="kw1">local</span> <span class="kw5">string</span> <span class="kw5">char</span>;
<span class="kw1">local</span> GPnode node;
  <span class="co1">//log(" random grow called on "$self@"depth = "$depth);</span>
  <span class="kw2">for</span> <span class="br0">(</span> i <span class="sy0">=</span><span class="nu0">0</span>; i<span class="sy0">&lt;</span>childcount;i<span class="sy0">++</span><span class="br0">)</span>
  <span class="br0">{</span>
   <span class="co1">//log(" randomgrow on "$self$"choosing child"$i);</span>
    <span class="kw2">if</span><span class="br0">(</span>depth <span class="sy0">==</span> maxdepth<span class="br0">)</span> <span class="br0">{</span>
     <span class="co1">// log("max depth reached");</span>
      <span class="kw5">char</span> <span class="sy0">=</span> <span class="kw3">mid</span><span class="br0">(</span>terminators,<span class="kw3">rand</span><span class="br0">(</span><span class="kw3">len</span><span class="br0">(</span>terminators<span class="br0">)</span><span class="br0">)</span>,<span class="nu0">1</span><span class="br0">)</span>;
  <span class="co1">//    log("char = "$char);</span>
      node <span class="sy0">=</span> addchild<span class="br0">(</span><span class="kw5">char</span>,i<span class="br0">)</span>;
    <span class="co1">//  log("new terminator node = "$node);</span>
    <span class="br0">}</span>
    <span class="kw2">else</span>
      <span class="br0">{</span>
       <span class="kw2">if</span><span class="br0">(</span>depth <span class="sy0">&lt;</span><span class="nu0">4</span><span class="br0">)</span> <span class="kw5">char</span> <span class="sy0">=</span> <span class="kw3">mid</span><span class="br0">(</span>functions,<span class="kw3">rand</span><span class="br0">(</span><span class="kw3">len</span><span class="br0">(</span>functions<span class="br0">)</span><span class="br0">)</span>,<span class="nu0">1</span><span class="br0">)</span>; <span class="co1">// add a bit of depth to start with for testing</span>
        <span class="kw2">else</span> <span class="kw5">char</span> <span class="sy0">=</span> <span class="kw3">mid</span><span class="br0">(</span>alltypes,<span class="kw3">rand</span><span class="br0">(</span><span class="kw3">len</span><span class="br0">(</span>alltypes<span class="br0">)</span><span class="br0">)</span>,<span class="nu0">1</span><span class="br0">)</span>;
      <span class="co1">// log("char = "$char);</span>
       node <span class="sy0">=</span> addchild<span class="br0">(</span> <span class="kw5">char</span>,i<span class="br0">)</span>;
      <span class="co1">// log("new node = "$node);</span>
       <span class="kw2">if</span><span class="br0">(</span>node.<span class="me0">Childcount</span> <span class="sy0">&gt;</span><span class="nu0">0</span><span class="br0">)</span>  node.<span class="me0">RandomGrow</span><span class="br0">(</span>depth<span class="sy0">+</span><span class="nu0">1</span>,maxdepth<span class="br0">)</span>;
      <span class="br0">}</span>
  <span class="br0">}</span>
 
<span class="br0">}</span>
</pre></div>
</div>
<p>RandomGrow is the function that creates random trees for seeding the initial population and for use in the genetic 'mutation' operation too. Note the plentiful commented out log statments... no more than curious fossils now, they were useful in the extreme when debugging this stuff, a comment after every line is usually a sign that I was tracking down an accessed none... I really should get round to deleting them&#160;:)</p>
<p>Since there are currently quite a few more terminal nodes defined that there are functions the tree had a habit of being very small most of the time so you'll notice that I make sure that all nodes up to depth 4 are chosen from the set of functions in order to give it a bit of depth... strictly speaking this is biasing what should be a totally random process, the fitness selection and evolution should take care of any runts, so this will probably go once things are fully set up. For now though it's a handy feature for testing.</p>
<p>Sometimes we might need to prune off the branch of a tree before replacing it with something else (like a branch chosen randomly from a tree that performs well at our chosen task, or just another random growth when mutating ) so the prune function recursively destroys nodes below the one on which it is first called.</p>
<p>It still feels a little crufty, that first check on childcount should be redundant really as the parent of any nodes with childcount == 0 will destroy them so that will go soon methinks. In fact a more elegant system would have terminal nodes destroy themselves but at the time I wasn't confident that a function in a node that called that nodes destroy() function would actually return, so nodes destroy their children instead (after having called prune on child nodes to ensure that their children get destroyed in turn ).</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="uscript source-uscript">
<pre class="de1">
<span class="kw1">function</span> prune<span class="br0">(</span><span class="br0">)</span>    <span class="co1">// remove objects below this node</span>
<span class="br0">{</span>
  <span class="kw1">local</span> <span class="kw5">int</span> i;
  <span class="kw2">if</span><span class="br0">(</span>childcount <span class="sy0">==</span> <span class="nu0">0</span> <span class="br0">)</span> <span class="kw2">return</span>;
  <span class="kw2">else</span>
    <span class="kw2">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">0</span>;i<span class="sy0">&lt;</span>childcount;i<span class="sy0">++</span><span class="br0">)</span>
      <span class="kw2">if</span><span class="br0">(</span>children<span class="br0">[</span>i<span class="br0">]</span>.<span class="me0">Childcount</span><span class="sy0">==</span><span class="nu0">0</span><span class="br0">)</span> children<span class="br0">[</span>i<span class="br0">]</span>.<span class="kw4">Destroy</span><span class="br0">(</span><span class="br0">)</span>;
        <span class="kw2">else</span>
           <span class="br0">{</span>
             children<span class="br0">[</span>i<span class="br0">]</span>.<span class="me0">prune</span><span class="br0">(</span><span class="br0">)</span>;
             children<span class="br0">[</span>i<span class="br0">]</span>.<span class="kw4">Destroy</span><span class="br0">(</span><span class="br0">)</span>;
             children<span class="br0">[</span>i<span class="br0">]</span><span class="sy0">=</span><span class="kw5">none</span>;
           <span class="br0">}</span>
  <span class="kw2">return</span>;
<span class="br0">}</span>
</pre></div>
</div>
<p>All of the tree manipulation functions used in creating new trees from an exisiting one need to chose a node at random and then do stuff to it. So the two functions below are used to:</p>
<ol>
<li>Count the nodes in the tree so that correct range can be used when a random number is generated to pick a node.</li>
<li>Actually return a reference to that random node</li>
</ol>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="uscript source-uscript">
<pre class="de1">
<span class="kw1">function</span> countnodes<span class="br0">(</span><span class="kw1">out</span> <span class="kw5">int</span> nodecount<span class="br0">)</span>
<span class="br0">{</span>
 <span class="kw1">local</span> <span class="kw5">int</span> i;
 <span class="co1">//recursively count nodes in tree below this one</span>
 nodecount <span class="sy0">++</span>;
 <span class="kw2">for</span> <span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">0</span>;i<span class="sy0">&lt;</span>childcount;i<span class="sy0">++</span><span class="br0">)</span>  children<span class="br0">[</span>i<span class="br0">]</span>.<span class="me0">countnodes</span><span class="br0">(</span>nodecount<span class="br0">)</span>;
 <span class="kw2">return</span>;
<span class="br0">}</span>
 
<span class="kw1">function</span> gpnode findnode<span class="br0">(</span><span class="kw1">out</span> <span class="kw5">int</span> nodenum<span class="br0">)</span> 
<span class="br0">{</span>
  <span class="kw1">local</span> <span class="kw5">int</span> i;
  <span class="kw1">local</span> gpnode result;
  nodenum <span class="sy0">--</span>;
  <span class="kw2">if</span><span class="br0">(</span>nodenum <span class="sy0">==</span><span class="nu0">0</span><span class="br0">)</span> <span class="kw2">return</span><span class="br0">(</span><span class="kw6">self</span><span class="br0">)</span>;
  <span class="kw2">else</span>
    <span class="br0">{</span>
       <span class="kw2">for</span> <span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">0</span>;i<span class="sy0">&lt;</span>childcount;i<span class="sy0">++</span><span class="br0">)</span>
         <span class="br0">{</span>
           result <span class="sy0">=</span> children<span class="br0">[</span>i<span class="br0">]</span>.<span class="me0">findnode</span><span class="br0">(</span>nodenum<span class="br0">)</span>;
           <span class="kw2">if</span><span class="br0">(</span>result <span class="sy0">!=</span> <span class="kw5">none</span><span class="br0">)</span>
              <span class="kw2">return</span><span class="br0">(</span>result<span class="br0">)</span>;
         <span class="br0">}</span>
       <span class="kw2">return</span><span class="br0">(</span><span class="kw5">none</span><span class="br0">)</span>;
    <span class="br0">}</span>
<span class="br0">}</span>
</pre></div>
</div>
<p>last but not least, cloneme() spawns a duplicate of a node and all the tree below it... yet more recursive majick&#160;:)</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="uscript source-uscript">
<pre class="de1">
<span class="kw1">function</span> gpnode cloneme<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
  <span class="co1">// clone this object, used recursively to duplicate subtrees</span>
  <span class="kw1">local</span> <span class="kw5">int</span> i;
  <span class="kw1">local</span> gpnode newnode;
 
  newnode <span class="sy0">=</span> <span class="kw4">spawn</span><span class="br0">(</span><span class="kw1">class</span><span class="br0">)</span>;
  <span class="kw2">for</span><span class="br0">(</span>i<span class="sy0">=</span><span class="nu0">0</span>;i<span class="sy0">&lt;</span>childcount;i<span class="sy0">++</span><span class="br0">)</span>
    newnode.<span class="me0">children</span><span class="br0">[</span>i<span class="br0">]</span> <span class="sy0">=</span> children<span class="br0">[</span>i<span class="br0">]</span>.<span class="me0">cloneme</span><span class="br0">(</span><span class="br0">)</span>;
    newnode.<span class="me0">mypawn</span><span class="sy0">=</span>mypawn;
  <span class="kw2">return</span><span class="br0">(</span>newnode<span class="br0">)</span>;
<span class="br0">}</span>
</pre></div>
</div>
<p>The most interesting things in the deafult properties are the strings which are used to hold lists of the tokens of the different types of nodes. Add to these when new nodes are made (my current one character per token scheme is nice and simple and I reckon if you find yourself running out of characters as node types undergo runaway expansion you need to think again about how much control you're willing to hand over to the evolution process... stick to minimal building blocks and let complexity sort itself out... another lesson from mr Turing&#160;:) )</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="uscript source-uscript">
<pre class="de1">
<span class="kw1">DefaultProperties</span>
<span class="br0">{</span>
<span class="kw7">DrawType</span><span class="sy0">=</span><span class="kw7">DT_none</span>
bCollideWorld<span class="sy0">=</span><span class="kw6">false</span>
bCollideActors<span class="sy0">=</span><span class="kw6">false</span>
bProjtarget<span class="sy0">=</span><span class="kw6">false</span>
childcount<span class="sy0">=</span><span class="nu0">1</span>
Terminators<span class="sy0">=</span><span class="st0">"RLKABCDEFGH"</span>
AllTypes<span class="sy0">=</span><span class="st0">"+-*%&lt;RLKABCDEFGHQNX"</span>
functions<span class="sy0">=</span><span class="st0">"+-*%&lt;QNX"</span>
<span class="br0">}</span>
</pre></div>
</div>
<p>So there you have it, the core node class. But for this to do any good we need a way of storing 'genes' and keeping track of which ones are doing well at our trials, as well as performing the actual 'breeding' and mutation of those high performers. Find the class that does this and further ramblings over at:</p>
<p><a href="Genes.html" title="Legacy:Genetic Programming/Genes">Genetic Programming/Genes</a></p>
<h2><span class="mw-headline" id="Your_Comments_Welcome">Your Comments Welcome</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://wiki.beyondunreal.com/edit/Legacy:Genetic_Programming/Nodes?section=1" title="Edit section: Your Comments Welcome">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><b>DJPaul:</b> Blimey.</p>
<p><b>Zedsquared</b> heh! I'll take that as a good 'Blimey' then&#160;;) food for thought I hope?</p>
<p><b>Chazums:</b> Strangely enough, just stumbled onto the idea of using this kind of thing for AI today. Nicely written walk through, makes things clearer in my mind too.</p>
<p><b>Zedsquared</b> Cheers Chazums, glad my explanations make some sense to you, here's a good link to a page full of such goodies (the whole site is good for AI too) <a rel="nofollow" class="external text" href="http://www.gameai.com/genetics.html">GameAi.com</a></p>

<!-- 
NewPP limit report
CPU time usage: 0.169 seconds
Real time usage: 0.171 seconds
Preprocessor visited node count: 111/1000000
Preprocessor generated node count: 248/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
-->

<!-- 
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 - -total
-->

<!-- Saved in parser cache with key wiki:pcache:idhash:1363-0!*!0!*!*!*!* and timestamp 20161215155416 and revision id 3460
 -->
</div><div class="printfooter">
Retrieved from "<a dir="ltr" href="https://wiki.beyondunreal.com/Legacy:Genetic_Programming/Nodes?oldid=3460">https://wiki.beyondunreal.com/Legacy:Genetic_Programming/Nodes?oldid=3460</a>"</div>
					<div id='catlinks' class='catlinks catlinks-allhidden'></div>					<!-- end content -->
										<div class="visualClear"></div>
				</div>
			</div>
		</div>
		<div id="column-one">
			<h2>Navigation menu</h2>
					<div id="p-cactions" class="portlet" role="navigation">
			<h3>Views</h3>

			<div class="pBody">
				<ul>
				<li id="ca-nstab-legacy" class="selected"><a href="Nodes.html">Legacy</a></li>
				<li id="ca-talk" class="new"><a href="https://wiki.beyondunreal.com/edit/Legacy_talk:Genetic_Programming/Nodes?redlink=1" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
				<li id="ca-edit"><a href="https://wiki.beyondunreal.com/edit/Legacy:Genetic_Programming/Nodes" title="You can edit this page. Please use the preview button before saving [e]" accesskey="e">Edit</a></li>
				<li id="ca-history"><a href="https://wiki.beyondunreal.com/history/Legacy:Genetic_Programming/Nodes" title="Past revisions of this page [h]" accesskey="h">History</a></li>
				</ul>
							</div>
		</div>
				<div class="portlet" id="p-personal" role="navigation">
				<h3>Personal tools</h3>

				<div class="pBody">
					<ul>
													<li id="pt-anonuserpage"><a href="../User_188.162.37.html" class="new" title="The user page for the IP address you are editing as [.]" accesskey=".">188.162.37.3</a></li>
													<li id="pt-anontalk"><a href="../User_talk_188.162.37.html" class="new" title="Discussion about edits from this IP address [n]" accesskey="n">Talk for this IP address</a></li>
													<li id="pt-createaccount"><a href="https://wiki.beyondunreal.com/Special:UserLogin?returnto=Legacy%3AGenetic+Programming%2FNodes&amp;type=signup" title="You are encouraged to create an account and log in; however, it is not mandatory">Create account</a></li>
													<li id="pt-login"><a href="https://wiki.beyondunreal.com/Special:UserLogin?returnto=Legacy%3AGenetic+Programming%2FNodes" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>
											</ul>
				</div>
			</div>
			<div class="portlet" id="p-logo" role="banner">
				<a href="../index.html" class="mw-wiki-logo" title="Visit the main page"></a>
			</div>
				<div class="generated-sidebar portlet" id="p-navigation" role="navigation">
		<h3>Navigation</h3>
		<div class='pBody'>
							<ul>
											<li id="n-mainpage"><a href="../index.html" title="Visit the main page [z]" accesskey="z">Main Page</a></li>
											<li id="n-portal"><a href="../Unreal_Wiki_Community_portal-2.html" title="About the project, what you can do, where to find things">Community portal</a></li>
											<li id="n-recentchanges"><a href="https://wiki.beyondunreal.com/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
											<li id="n-randompage"><a href="https://wiki.beyondunreal.com/Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
											<li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>
											<li id="n-Forums-.28General.29"><a href="https://forums.beyondunreal.com/forums/wiki-general.250/" rel="nofollow">Forums (General)</a></li>
											<li id="n-Forums-.28Technical.29"><a href="https://forums.beyondunreal.com/forums/wiki-technical.251/" rel="nofollow">Forums (Technical)</a></li>
									</ul>
					</div>
		</div>
			<div id="p-search" class="portlet" role="search">
			<h3><label for="searchInput">Search</label></h3>

			<div id="searchBody" class="pBody">
				<form action="https://wiki.beyondunreal.com/" id="searchform">
					<input type='hidden' name="title" value="Special:Search"/>
					<input type="search" name="search" placeholder="Search" title="Search Unreal Wiki [f]" accesskey="f" id="searchInput" />
					<input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchGoButton" class="searchButton" />&#160;
						<input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton" />
				</form>

							</div>
		</div>
			<div class="portlet" id="p-tb" role="navigation">
			<h3>Tools</h3>

			<div class="pBody">
				<ul>
											<li id="t-whatlinkshere"><a href="https://wiki.beyondunreal.com/Special:WhatLinksHere/Legacy:Genetic_Programming/Nodes" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
											<li id="t-recentchangeslinked"><a href="https://wiki.beyondunreal.com/Special:RecentChangesLinked/Legacy:Genetic_Programming/Nodes" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
											<li id="t-specialpages"><a href="https://wiki.beyondunreal.com/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
											<li id="t-print"><a href="https://wiki.beyondunreal.com/Legacy:Genetic_Programming/Nodes?printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>
											<li id="t-permalink"><a href="https://wiki.beyondunreal.com/Legacy:Genetic_Programming/Nodes?oldid=3460" title="Permanent link to this revision of the page">Permanent link</a></li>
											<li id="t-info"><a href="https://wiki.beyondunreal.com/info/Legacy:Genetic_Programming/Nodes" title="More information about this page">Page information</a></li>
									</ul>
							</div>
		</div>
			</div><!-- end of the left (by default at least) column -->
		<div class="visualClear"></div>
					<div id="footer" role="contentinfo">
						<div id="f-copyrightico">
									<a href="https://creativecommons.org/licenses/by-nc-sa/3.0/"><img src="../../licensebuttons.net/l/by-nc-sa/3.0/88x31.png" alt="Attribution-Noncommercial-Share Alike 3.0" width="88" height="31" /></a>
							</div>
					<div id="f-poweredbyico">
									<script async src="../../pagead2.googlesyndication.com/pagead/js/f.txt"></script>
        <!-- Home Page -->
        <ins class="adsbygoogle"
             style="display:inline-block;width:728px;height:90px"
             data-ad-client="ca-pub-9605963037553244"
             data-ad-slot="9528541415"></ins>
        <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
							</div>
					<ul id="f-list">
									<li id="lastmod"> Last modified at 03:54, 25 July 2004.</li>
									<li id="copyright">Licensed as <a href="../Unreal_Wiki_Copyrights.html" title="Unreal Wiki:Copyrights">Attribution-Noncommercial-Share Alike 3.0</a>.</li>
									<li id="privacy"><a href="../Unreal_Wiki_Privacy_policy.html" title="Unreal Wiki:Privacy policy">Privacy policy</a></li>
									<li id="about"><a href="../Unreal_Wiki_About.html" title="Unreal Wiki:About">About Unreal Wiki</a></li>
									<li id="disclaimer"><a href="../Unreal_Wiki_General_disclaimer.html" title="Unreal Wiki:General disclaimer">Disclaimers</a></li>
							</ul>
		</div>
		</div>
		<script>if(window.jQuery)jQuery.ready();</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest"],null,true);
}</script>
<script>if(window.mw){
document.write("\u003Cscript src=\"https://wiki.beyondunreal.com/w/load.php?debug=false\u0026amp;lang=en\u0026amp;modules=site\u0026amp;only=scripts\u0026amp;skin=monobook\u0026amp;*\"\u003E\u003C/script\u003E");
}</script>
<script>if(window.mw){
mw.config.set({"wgBackendResponseTime":83});
}</script></body>
<!-- Mirrored from wiki.beyondunreal.com/Legacy:Genetic_Programming/Nodes by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 16 Dec 2016 09:41:30 GMT -->
</html>
