<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">

<!-- Mirrored from wiki.beyondunreal.com/Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask) by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 16 Dec 2016 07:52:50 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8" />
<title>Everything you ever wanted to know about replication (but were afraid to ask) - Unreal Wiki</title>
<meta name="generator" content="MediaWiki 1.25.1" />
<link rel="alternate" type="application/x-wiki" title="Edit" href="https://wiki.beyondunreal.com/edit/Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask)" />
<link rel="edit" title="Edit" href="https://wiki.beyondunreal.com/edit/Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask)" />
<link rel="shortcut icon" href="w/uewiki-favicon.png" />
<link rel="search" type="application/opensearchdescription+xml" href="w/opensearch_desc.php" title="Unreal Wiki" />
<link rel="EditURI" type="application/rsd+xml" href="w/api251f.php?action=rsd" />
<link rel="alternate" hreflang="x-default" href="Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask).html" />
<link rel="copyright" href="Unreal_Wiki_Copyrights.html" />
<link rel="alternate" type="application/atom+xml" title="Unreal Wiki Atom feed" href="https://wiki.beyondunreal.com/Special:RecentChanges?feed=atom" />
<link rel="stylesheet" href="w/load2743.css?debug=false&amp;lang=en&amp;modules=ext.geshi.language.uscript%7Cmediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.content.externallinks%7Cmediawiki.skinning.interface%7Cmediawiki.ui.button%7Cskins.monobook.styles&amp;only=styles&amp;skin=monobook&amp;*" />
<!--[if IE 6]><link rel="stylesheet" href="/w/skins/MonoBook/IE60Fixes.css?303" media="screen" /><![endif]-->
<!--[if IE 7]><link rel="stylesheet" href="/w/skins/MonoBook/IE70Fixes.css?303" media="screen" /><![endif]--><meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="w/load484a.css?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=monobook&amp;*" />
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}
/* cache key: wiki:resourceloader:filter:minify-css:7:29b70323345a439ab9ed7007e0c178a6 */</style>
<script src="w/load9316.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=monobook&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask)","wgTitle":"Everything you ever wanted to know about replication (but were afraid to ask)","wgCurRevisionId":45930,"wgRevisionId":45930,"wgArticleId":29127,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Programming articles","Replication"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask)","wgRelevantArticleId":29127,"wgIsProbablyEditable":true,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgCategoryTreePageCategoryOptions":"{\"mode\":0,\"hideprefix\":20,\"showcount\":true,\"namespaces\":false}"});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function($,jQuery){mw.user.options.set({"variant":"en"});});mw.loader.implement("user.tokens",function($,jQuery){mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\"});});
/* cache key: wiki:resourceloader:filter:minify-js:7:a5c52c063dc436c1ca7c9f456936a5e9 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax"]);
}</script>
</head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-Everything_you_ever_wanted_to_know_about_replication_but_were_afraid_to_ask skin-monobook action-view">
<div id="globalWrapper">
		<div id="column-content">
			<div id="content" class="mw-body" role="main">
				<a id="top"></a>
									<div id="siteNotice"><div id="localNotice" lang="en" dir="ltr"><p>The three virtues of a programmer: Laziness, Impatience, and Hubris. &#8211; Larry Wall
</p></div></div>
				<div class="mw-indicators">
</div>
				<h1 id="firstHeading" class="firstHeading" lang="en">Everything you ever wanted to know about replication (but were afraid to ask)</h1>

				<div id="bodyContent" class="mw-body-content">
					<div id="siteSub">From Unreal Wiki, The Unreal Engine Documentation Site</div>
					<div id="contentSub"></div>
										<div id="jump-to-nav" class="mw-jump">Jump to: <a href="#column-one">navigation</a>, <a href="#searchInput">search</a></div>

					<!-- start content -->
					<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><p>Replication is a mighty beast lurking inside the Unreal Engine that even seasoned UnrealScript programmers treat with a lot of respect. With this article I'll try to explain how replication works and hopefully get rid of some myths and misunderstandings on that topic.</p>
<p>This article should be considered more a technical documentation than a tutorial. It specifically avoids code examples, because the different engine generations require expressing the same concept or feature in different ways. See <a href="Replication_Idioms.html" title="Replication Idioms">Replication Idioms</a> for actual examples of some common replication tasks.</p>
<p>A <a rel="nofollow" class="external text" href="http://www.utzone.de/forum/showthread.php?t=2804">German version of this article</a> is available over at UTzone.de.</p>
<p></p>
<div id="toc" class="toc">
<div id="toctitle">
<h2>Contents</h2>
</div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Things_to_keep_in_mind_while_reading"><span class="tocnumber">1</span> <span class="toctext">Things to keep in mind while reading</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Background_-_What_you_start_with_on_the_client_side"><span class="tocnumber">2</span> <span class="toctext">Background - What you start with on the client side</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Replication_basis_-_Actor_replication"><span class="tocnumber">3</span> <span class="toctext">Replication basis - Actor replication</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Network_relevance_-_Which_actors_are_replicated"><span class="tocnumber">4</span> <span class="toctext">Network relevance - Which actors are replicated</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Variable_replication_-_Updating_properties_on_the_client"><span class="tocnumber">5</span> <span class="toctext">Variable replication - Updating properties on the client</span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#Replication_conditions"><span class="tocnumber">5.1</span> <span class="toctext">Replication conditions</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#What_is_replicated_and_when.3F"><span class="tocnumber">5.2</span> <span class="toctext">What is replicated and when?</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Value_compression"><span class="tocnumber">5.3</span> <span class="toctext">Value compression</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Detecting_replicated_values_on_the_client"><span class="tocnumber">5.4</span> <span class="toctext">Detecting replicated values on the client</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#Restrictions"><span class="tocnumber">5.5</span> <span class="toctext">Restrictions</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-11"><a href="#Function_call_replication_-_Sending_messages_between_server_and_client"><span class="tocnumber">6</span> <span class="toctext">Function call replication - Sending messages between server and client</span></a>
<ul>
<li class="toclevel-2 tocsection-12"><a href="#Calling_replicated_functions"><span class="tocnumber">6.1</span> <span class="toctext">Calling replicated functions</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#Reliability"><span class="tocnumber">6.2</span> <span class="toctext">Reliability</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-14"><a href="#Ok.2C_what.27s_with_that_.22simulated.22_keyword.3F"><span class="tocnumber">7</span> <span class="toctext">Ok, what's with that "simulated" keyword?</span></a></li>
</ul>
</div>
<p></p>
<h2><span class="mw-headline" id="Things_to_keep_in_mind_while_reading">Things to keep in mind while reading</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://wiki.beyondunreal.com/edit/Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask)?section=1" title="Edit section: Things to keep in mind while reading">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>We're on the Unreal Wiki, a site full of tutorials and reference documentation. I won't go into detail for every feature, because you can find that elsewhere. You really should have gathered some experience with the language itself and know how to use it properly before you take on scary features like replication. If you still have a question, try looking it up on the wiki first. If you can't find an answer, you can of course still ask on this article's discussion page. For more complex questions you might want to post on a forum instead, though.</p>
<p>One fact people probably don't expect is that the demo recording feature of the UT series of games is internally handled much like a network game. When you record a demo you are something similar to a listen server and when you play back a demo you are a client. Even if you write an offline-only mod, as soon as you want to support demo recording, you will have to deal with replication. The difference between demos and network play is that when recording a demo, the "server" doesn't expect the client to respond (network traffic is just dumped to a file) and that the "client" in demo playback will discard any data that is supposed to be sent to the server.</p>
<p>Another interesting case is UTV. A UTV server basically is a proxy server that looks like a special client on the game server, but acts as a server to its own clients. A UTV server's clients are spectators that can interact with each other via chat, but except for the primary client their data stays on the UTV proxy and doesn't reach the game server. Additionally the UTV proxy intentionally delays the game server's data so UTV clients cannot be used by the players to cheat in some way.</p>
<h2><span class="mw-headline" id="Background_-_What_you_start_with_on_the_client_side">Background - What you start with on the client side</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://wiki.beyondunreal.com/edit/Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask)?section=2" title="Edit section: Background - What you start with on the client side">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>I won't explain how you should set up a server and connect to it with a game client, that part is covered in great detail elsewhere. This section is about what you start with after the game loaded a map on the client.</p>
<p>To make it short: You start with most of what the mapper added to his level. Particularly all non-actor objects (sounds, textures, meshes) used in the map will be loaded. Some of the actors the mapper placed will be missing, though. To be precise, the engine deletes all actors that have neither <i>bStatic</i> nor <i>bNoDelete</i> set to True. Level geometry, most lights, movers, navigation points, keypoints, emitters, decorations and many other actors aren't affected by this. However, all Pawns (especially placed monsters, vehicles and turrets), Projectiles, in UE1/2 also Pickups, and triggers will be gone. All of the remaining actors will have their <i>Role</i> and <i>RemoteRole</i> values exchanged, except for ClientMovers and similar actors marked as <i>bClientAuthoritative</i>. Quite a lot of the static and non-deletable actors end up with <i>Role</i> set to <code>ROLE_None</code> here, but that doesn't mean they don't exist on the client. It only means they won't receive any property updates through replication.</p>
<p>See <a href="What_happens_at_map_startup.html" title="What happens at map startup">What happens at map startup</a> for what else happens before replication kicks in.</p>
<h2><span class="mw-headline" id="Replication_basis_-_Actor_replication">Replication basis - Actor replication</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://wiki.beyondunreal.com/edit/Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask)?section=3" title="Edit section: Replication basis - Actor replication">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<div class="floatright"><a href="File_StatNet.html" class="image" title="F6 network stats."><img alt="F6 network stats." src="w/images/StatNet.png" width="224" height="235" /></a></div>
<p>So, how does the client get to know about them? They do show up when you play the game, right? The basic concept responsible here is <b>actor replication</b>. For each relevant actor, the engine creates an "actor channel" between the server and the target client. The number of active channels can be viewed via the <code>stat net</code> command, which is usually bound to the F6 key. Note that the number of channels listed there is the total number of channels. Most of these are actor channels, but the engine also has other channel types, e.g. for voice chat.</p>
<p>There are actually two flavors of actor replication, one for static and non-deletable actors (those that aren't deleted at map load on the client) and one for any other actors that were either deleted at map load or spawned on the server at runtime. As mentioned above, static or non-deletable actors already exist in the client world, so their flavor of actor replication just establishes a channel between the corresponding server and client instances. It should be mentioned that static actors can only be subject to replication if they were already marked as bAlwaysRelevant before map load.</p>
<p>The other version is for actors that are neither <i>bStatic</i> nor <i>bNoDelete</i> (let's call them "runtime actors" because they can be spawned and destroyed at runtime) and requires a bit more work, as the target actor does not exist on the client. The server basically tells the client to spawn an actor of the required type and it also tells where to spawn it. By spawning the actor on the client, all its properties start at the class default values. See <a href="What_happens_when_an_Actor_is_spawned.html" title="What happens when an Actor is spawned">What happens when an Actor is spawned</a> for details on how actors are initialized. The most important part here is that the actor gets its Role and RemoteRole values exchanged before any UnrealScript code is executed.</p>
<p>In case this isn't immediately obvious: Runtime actors placed by the mapper are deleted at map load and then possibly spawned again through actor replication. When they are replicated, all their properties are reset to class default values. Some of the change done by the mapper might later be reconstructed through other means, but for now they are gone.</p>
<h2><span class="mw-headline" id="Network_relevance_-_Which_actors_are_replicated">Network relevance - Which actors are replicated</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://wiki.beyondunreal.com/edit/Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask)?section=4" title="Edit section: Network relevance - Which actors are replicated">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Most of what this article explained was from the network client's point of view. Let's switch to the server side for a while to discuss a very important thing, network bandwidth. Bandwidth is usually the most-restricted parameter in a network. Data is sent sequentially, so apart from the time it takes for data to travel anyway, some of the data needs to wait while other data is transmitted. This further increases response times ("ping"), which is undesirable in most games. Games can't reduce the actual travel time of the data, that's a fixed property of the underlying network architecture. They can, however, attempt to reduce the data's waiting time by reducing the overall amount of data to transmit. The Unreal Engine employs several tricks to reduce the overall amount of data, but the best way always is to not send any data at all.</p>
<p>To figure out which actors need to be replicated to a client at all, the engine performs several checks to see if the actor is <b>relevant</b> to the client. These checks can be summed up in the following rules that will be tested roughly in the given order:</p>
<ol>
<li>If the actor is <i>bAlwaysRelevant</i>, it is relevant to the client.</li>
<li>If the client or its view target owns the actor, it is relevant.</li>
<li>If the client is a UTV see-all spectator, the actor is relevant.</li>
<li>If the client can hear the actor's ambient sound, it is relevant.</li>
<li>If the actor is based on (or attached to the bone of) another actor, it is relevant to the client if the other actor is.</li>
<li>If the actor is <i>bHidden</i> or <i>bOnlyOwnerSee</i> and neither blocks other actors nor has an ambient sound, it is <b>not</b> relevant to the client.</li>
<li>If the actor is in a zone with distance fog and is further away from the client's view location than the distance fog end, it is <b>not</b> relevant to the client.</li>
<li>If there is BSP geometry between the client's view location and the actor's center (!), the actor is <b>not</b> relevant.</li>
<li>The server may decide to check if the actor is behind some terrain and/or beyond its <i>CullDistance</i> if it needs to save bandwidth, which may result in the actor being <b>not</b> relevant to the client.</li>
<li>The actor is relevant to the client.</li>
</ol>
<p>Note that, while they usually prevent an actor from being rendered, <a href="Anti_portals.html" title="Anti portals">anti portals</a> do not affect network relevance, probably because testing every actor against every single AntiPortalActor for every client may be far too expensive.</p>
<p>Once an actor became relevant, it will continue to be considered relevant until the above rules fail for more than a few seconds. The duration is configured via <code>RelevantTimeout=...</code> under <code>[IpDrv.TcpNetDrv]</code> in the server's main configuration file for UE1/2 or the Engine.ini in UE3. The default value is 5 seconds and provides a good balance between getting rid of non-relevant actors and not having to restart replication too often for actors that often switch between being relevant and being not.</p>
<p>If a previously net-relevant actor is really no longer relevant, its channel to the client is closed and the actor is destroyed on the client. (See <a href="What_happens_when_an_Actor_is_destroyed.html" title="What happens when an Actor is destroyed">What happens when an Actor is destroyed</a> for details.) If the actor becomes relevant again later, it will be spawned again as a completely new actor. If an actor is destroyed on the server, its channel is closed as well, causing the corresponding actor instances on all clients to be destroyed.</p>
<p>There are also two other ways to close an actor channel, which don't destroy the client instance. When that happens, the client takes over "simulation" of the actor behavior without any further help from the server. One way is the property <i>bNetTemporary</i>, which closes the actor channel immediately after the initial set of properties has been replicated (see below). This mode is used for most projectiles that don't change their movement after spawning, except for a potential influence of gravity. Projectiles that allow interaction other than the usual explode/bounce-on-impact logic usually don't use <i>bNetTemporary</i>. This includes projectiles that can be blown up (e.g. shock projectile, Redeemer or AVRiL rocket), that track down a target (e.g. seeking rockets or spider mines) or that simply stick to a target (e.g. bio goo or sticky grenades). <i>bNetTemporary</i> also has the advantage that the server doesn't need to remember which variable values it replicated to clients, but more on that later.</p>
<p>The other way is the <i>bTearOff</i> property, which also closes the actor channel, but it also swaps the <i>Role</i> and <i>RemoteRole</i> properties of the actor again so the client side instance becomes an "authoritative" instance. Unlike <i>bNetTemporary</i>, which can only be set in the <a href="Defaultproperties.html" title="Defaultproperties">defaultproperties</a>, <i>bTearOff</i> is set on the server at runtime to "tear off" replication to all clients at the same time. On the clients the actor was relevant to, the event <i>TornOff()</i> is called for the actor. Once an actor is "torn off", it will no longer be replicated to new clients it might become relevant to.</p>
<h2><span class="mw-headline" id="Variable_replication_-_Updating_properties_on_the_client">Variable replication - Updating properties on the client</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://wiki.beyondunreal.com/edit/Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask)?section=5" title="Edit section: Variable replication - Updating properties on the client">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Alright, now that you know how actors are brought to existence on clients, it's time to think about how to get modifications across the network. Remember, when a replicated actor is spawned on a client, it starts with its class defaults and the only information from the server is the actor's location and potentially its rotation, if it matters. Any other properties are sent separately through what is called <b>variable replication</b>.</p>
<p>Replicated properties are always replicated from the server to all or a specific subset of the clients, but of course only to clients to which a channel for the actor exists. In Unreal Engine 1 there was also the possibility to replicate variables from the client owning the actor to the server, but that feature has been dropped in favor of sending the values via replicated function calls. (We'll see about that one later.) One left-over of that two-way replication is that almost all variable replication conditions in stock code contain the term <code>Role == ROLE_Authority</code>.</p>
<h3><span class="mw-headline" id="Replication_conditions">Replication conditions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://wiki.beyondunreal.com/edit/Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask)?section=6" title="Edit section: Replication conditions">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Wait, what's a "replication condition"? Well, as mentioned before, variable replication can be restricted to a specific subset of the relevant clients. The subset is selected via a <a href="Bool.html" title="Bool" class="mw-redirect">bool</a>-type expression known as the <b>replication condition</b>. Replication conditions are specified in a special area of the source code, the <a href="Replication_block.html" title="Replication block">replication block</a>. Each class may only contain one replication block. Inside there may be one or more replication conditions, each applying to one or more variables or functions. Only one condition may be specified for a variable or function and you are not allowed to specify replication conditions for members inherited from a parent class.</p>
<p>A typical replication block in UE2 might look as follows:</p>
<div dir="ltr" class="mw-geshi mw-code mw-content-ltr">
<div class="uscript source-uscript">
<pre class="de1">
<span class="kw1">replication</span>
<span class="br0">{</span>
  <span class="kw1">reliable</span> <span class="kw2">if</span> <span class="br0">(</span>bNetOwner<span class="br0">)</span>
    ThisVarOnlyConcernsTheOwner;
 
  <span class="kw1">reliable</span> <span class="kw2">if</span> <span class="br0">(</span>bNetInitial<span class="br0">)</span>
    ThisVarIsOnlyReplicatedOnce;
<span class="br0">}</span>
</pre></div>
</div>
<p>In UE3 it would be similar, except that the "reliable" or "unreliable" keyword is missing. That keyword doesn't have any effect on variable replication, it only exists because it affects the way function calls are replicated, but we'll get into that later.</p>
<p>Technically the boolean expression between the parentheses after the "if" is standard UnrealScript code, so you could call functions there if you want. In practice, however, nobody will do that because the time and frequency at which replication conditions are evaluated is unpredictable. Also, this is deep inside network code and should be as quick as possible. Because of that, some classes have their replication conditions implemented in <a href="https://wiki.beyondunreal.com/edit/Native_code?redlink=1" class="new" title="Native code (page does not exist)">native code</a>, which is specified in the class declaration via the <a href="NativeReplication.html" title="NativeReplication" class="mw-redirect">NativeReplication</a> modifier. These classes still have a replication block so you can figure out when exactly the various properties are replicated. Also, NativeReplication only applies to variable replication, not to replicated function calls.</p>
<p>So, what kind of conditions can you use? Here are a few properties you may find useful:</p>
<dl>
<dt>bNetInitial</dt>
<dd>True only for the initial bunch of variables replicated in addition to the information for spawning the actor on the client.</dd>
<dt>bNetDirty<sup>2,3</sup></dt>
<dd>True whenever variables changed on the actor. To be honest I'm not entirely sure why this exists as variables always only get replicated if they changed from what the server thinks the client's value is.</dd>
<dt>bNetOwner</dt>
<dd>True only if the actor is owned by the client.</dd>
<dt>bDemoRecording</dt>
<dd>True if replicating to the demo recording driver instead of a "real" network connection.</dd>
<dt>bClientDemoRecording</dt>
<dd>True if the demo is being recorded on a network client, false if recording offline or on a server or not recording a demo at all.</dd>
<dt>bRepClientDemo</dt>
<dd>True on the server if the actor is owned by a client that currently records a demo.</dd>
<dt>Level.ReplicationViewer<sup>2</sup></dt>
<dd>The PlayerController of the client currently replicating to.</dd>
<dt>Level.ReplicationViewTarget<sup>2</sup></dt>
<dd>The ReplicationViewer's current view target.</dd>
<dt>WorldInfo.ReplicationViewers<sup>3</sup></dt>
<dd>A <a href="Dynamic_array.html" title="Dynamic array" class="mw-redirect">dynamic array</a> with information about the PlayerController(s) on the target client, their view target, view location and view direction. It's an array because UE3 allows more than one player on a client if splitscreen mode is enabled.</dd>
<dt>Role</dt>
<dd>This actor's local network role. You only need to check it when replicating variables in UE1 or when replicating function calls in UE1/2.</dd>
</dl>
<p>If you look around in the replication blocks of stock classes, you may find other variables being used. For example an actor's <i>Mesh</i> is only replicated if the <i>DrawType</i> is <code>DT_Mesh</code>.</p>
<h3><span class="mw-headline" id="What_is_replicated_and_when.3F">What is replicated and when?</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://wiki.beyondunreal.com/edit/Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask)?section=7" title="Edit section: What is replicated and when?">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>So, when exactly does variable replication happen? The short answer is "between world updates, if anything changed". But the server doesn't really check all actors after each tick. Each actor class has a <i>NetUpdateFrequency</i>, which tells how often per second the actor should be checked for changed replicated variables. The first check is of course done right when the actor becomes relevant to the client and <i>bNetTemporary</i> actors won't get any further updates after that. For all other relevant actors, the engine repeats checks for changed variables about every <code>1.0/NetUpdateFrequency</code>. Usually there's only limited bandwidth available, so the engine needs to prioritize the various actors. This is done via the <i>NetPriority</i> property. The higher an actor's priority is, the more likely it will be updated. However, lower priority actors won't "starve", because the longer an actor has to wait for its update check, the more likely it will be updated during the next round of checks.</p>
<p>In Unreal Engine 1 you can't control at which time an update check for replicated variables happens. In Unreal Engine 2 you can force (well, at least strongly suggest) updates earlier by setting the <i>NetUpdateTime</i> to a value in the past, e.g. <code>Level.TimeSeconds - 1</code>. Unreal Engine 3 provides the property <i>bForceNetUpdate</i>, which can be set to True for an immediate update.</p>
<p>The server keeps track of what each client knows about the actors replicated to it and their replicated variable values. The initial assumption about what the client knows is built based on the serverside class defaults, which includes localized and configurable values read from the localization/config files. In other words, config/globalconfig properties might not initially get replicated because the server thinks the client already knows about them. It is really recommended you use separate properties for replicating configurable values. Similarly if you edit class defaults at runtime and then spawn a new replicated actor, the server will not know you have changed the defaults and just assume the client knows about it.</p>
<p>Every time a variable is send to the client, the server will remember its value for that client. This may use a good amount of memory, but it helps the server save bandwidth by not having to replicate the same value again. Consider the following scenario: The server replicated a certain value to the client, then the variable is modified on the server multiple times, eventually ending up the same as it was when the server replicated it. None of the changes were replicated yet because they happened too quickly, but the server marked the actor as having changed properties. Now it's time again to check for properties to replicate. The server will look up what values it sent to the client last time and finds that the replicated property hasn't actually changed. To save bandwidth, the server won't send the property value again, because the client already knows about it.</p>
<h3><span class="mw-headline" id="Value_compression">Value compression</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://wiki.beyondunreal.com/edit/Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask)?section=8" title="Edit section: Value compression">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>As mentioned in the section about relevance, the engine has a few tricks to reduce the amount of data it needs to send. One of these tricks is that it compresses certain value types for transfer and uncompressing them. This compression is not lossless, but actually changes the value that arrives at the client. This doesn't apply to basic types, but only to certain structs:</p>
<dl>
<dt><a href="Vector.html" title="Vector">Vector</a></dt>
<dd>The components are rounded to the nearest integer and send as integer data. This way small vectors only require several bits up to a few bytes, while the original three uncompressed <a href="Float.html" title="Float" class="mw-redirect">float</a> values would have required 12 bytes. If you need more than integer precision, you should multiply the vector by a scalar value before assigning it to the replicated variable.</dd>
<dt><a href="Rotator.html" title="Rotator">Rotator</a></dt>
<dd>Only bits 9 to 16 of the components are transfered, which corresponds to the operation <code><i>C</i> &amp; 0xff00</code>. That way the required data amount is reduced from 12 to about 3 bytes. (It seems zero components even only take up a single bit, reducing the minimum size to 3 bits for the zero rotator.) The compression restricts replicated rotator values to rotations and makes them useless for rotation rates. To replicate a rotation rate, you could copy the rotator components to the components of a vector variable. Note that you shouldn't use <a href="Typecasting.html" title="Typecasting">typecasting</a> to vector because that results in a unit vectors, which not only discards the Roll component entirely, but also is heavily affected by vector compression.</dd>
<dt><a href="Quat.html" title="Quat" class="mw-redirect">Quat</a></dt>
<dd>Values are assumed to be unit quaternions, allowing the engine to drop the W component from replication entirely and calculating it from X, Y and Z on the client. As a result Quat values require only 12 instead of 16 bytes for the remaining 3 float values.</dd>
<dt>CompressedPosition<sup>2</sup></dt>
<dd>The struct consists of vectors for location and velocity and a rotator for rotation. The vectors are replicated as usual, but because this struct is used to pack a player position, the Roll component of the rotation is not replicated at all, while the Pitch and Yaw components receive the usual compression to byte size.</dd>
<dt>Plane</dt>
<dd>Components are rounded to signed integers in the range [-32768,32767]. That corresponds to a data size reduction of 50%.</dd>
</dl>
<h3><span class="mw-headline" id="Detecting_replicated_values_on_the_client">Detecting replicated values on the client</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://wiki.beyondunreal.com/edit/Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask)?section=9" title="Edit section: Detecting replicated values on the client">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Most of the time you just let values replicate so they are available on the client. Sometimes, however, you will want to react to certain property changes immediately. Depending on the engine generation you have different options to react to replicated variables changing.</p>
<p>In Unreal Engine 1 you're entirely on your own as there is no notification. You will have to keep a backup copy of the variable you are monitoring and frequently check the backup against the original, e.g. in <i>Tick()</i> or a <i>Timer()</i>.</p>
<p>Unreal Engine 2 at least tells you <i>that</i> it received replicated variables, but it doesn't tell you <i>which</i> variables were replicated. You need to set <i>bNetNotify</i> to True on the client to receive a <i>PostNetReceive()</i> call when a new bunch of replicated variable values arrived. It should be mentioned that if you only want to get a notification for a single, infrequent event, you can toggle the value of <i>bClientTrigger</i>. This will call the <i>ClientTrigger()</i> event as soon as the changed value arrives on the client.</p>
<p>Finally in Unreal Engine 3 you don't have to figure out which variable was changed, because the engine tells you. To get replication notifications, simply declare the corresponding variable with the modifier <a href="RepNotify.html" title="RepNotify" class="mw-redirect">RepNotify</a> and the engine will call the <i>ReplicatedEvent()</i> function with the variable's name as the parameter whenever a value for that variable is received.</p>
<p>Note that variables are not always replicated immediately when they are changed. Usually the engine makes sure there are at least 1/<i>NetUpdateFrequency</i> seconds between variable updates for a single actor. Also, actors with a higher <i>NetPriority</i> are usually preferred when there's not enough space to replicate changed properties in all relevant actors. Actors with a lower priority may have to wait longer for their variables to replicate.</p>
<p>To get instant replication at the expense of the ability to pick more than one target client, you can use replicated function calls instead.</p>
<h3><span class="mw-headline" id="Restrictions">Restrictions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://wiki.beyondunreal.com/edit/Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask)?section=10" title="Edit section: Restrictions">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Not all <a href="Types.html" title="Types">types</a> can be replicated, others may only replicate properly under certain conditions. For example <a href="Dynamic_arrays.html" title="Dynamic arrays">dynamic arrays</a> cannot be replicated at all. Any variable's value must at least fit into a single network packet to be replicated, but if multiple values from the same actor are small enough to fit into the same packet, then they will be transferred together, saving some overhead.</p>
<p>Strings and <a href="Struct.html" title="Struct" class="mw-redirect">structs</a> can only be replicated as a whole, while the elements of a static array are treated as separate variables for replication. That means, a static array with hundreds of relatively small elements may replicate just fine, while a long string or a very complex struct may fail. Note that static arrays in structs are subject to the "structs are replicated as a unit" rule, while dynamic arrays in a struct will be excluded from the struct replication data.</p>
<p>Actor or object references are another thing where you need to pay attention. Actor references can only be replicated if the referenced actor is either <i>bStatic</i> or <i>bNoDelete</i> or is currently relevant to the target client. Non-actor object references, such as classes, sounds, textures or meshes, will only reach the client if the object wasn't created at runtime. Non-Actor objects (not a reference, but the object itself) are generally <b>not</b> replicated, so you always need an actor if you want to establish a "connection" between the server and a client.</p>
<p>It might be obvious from the article already, but just in case: There is no way to achieve direct replication between clients. Clients can only communicate with the server.</p>
<h2><span class="mw-headline" id="Function_call_replication_-_Sending_messages_between_server_and_client">Function call replication - Sending messages between server and client</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://wiki.beyondunreal.com/edit/Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask)?section=11" title="Edit section: Function call replication - Sending messages between server and client">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The word "messages" should be understood in a much wider range than just text messages. UnrealScript <a href="Functions.html" title="Functions">functions</a> can have up to 16 parameters and each parameter can have one of many built-in and custom types. Replicated function calls can use almost the entire range of feature you can imagine. For parameters the same restrictions apply as for variable replication, with two additions: The entire function call with all parameter values must fit into a single network packet, and only the first element of a static array parameter is replicated, the others are set to their corresponding null value. If you hit the upper data size limit, you may have to find a way to break down the data into separate calls. If you need to replicate a static array, wrap it into a struct. This also makes passing it around in other cases much easier because structs can be copied as a whole, while static arrays cannot.</p>
<p>Ok, that said, let's look at how to replicate a function call. This differs between UE1/2 and UE3. In engine generations 1 and 2 you use the <a href="Replication_block.html" title="Replication block">replication block</a> to specify when to replicate the function call to the remote end. Usually you will include <code>Role == ROLE_Authority</code> for functions you want to send from the server to the client and <code>Role&#160;!= ROLE_Authority</code> for functions the client should send to the server other terms are extremely rare in the replication condition. Keep one thing in mind: Function replication always implies <i>bNetOwner</i>, i.e. function call are only replicated if the executing actor is owned by a client, and the call will only be replicated to/from that owning client. (Being owned by a client means the actor is directly or indirectly owned by the client's PlayerPawn (UE1)/PlayerController. If walking up the "owner chain" does not end at a PlayerPawn/PlayerController that belongs to a client, then the actor is not owned by any client.)</p>
<p>Unreal Engine 3 no longer uses the replication block to specify replicated function conditions. Instead it provides function modifiers to specify the replication direction. The modifier <b>server</b> means if the function is called on the client owning the actor, the call should be replicated to the server, while the modifier <b>client</b> means the server should replicate the function call to the client owning the actor. Because it makes sense, the <b>client</b> modifier also implies the modifier <b>simulated</b> to ensure the function can definitely be executed on the client when it arrives. Another modifier is <b>demorecording</b>, which means the function should be replicated to the demo recording driver.</p>
<h3><span class="mw-headline" id="Calling_replicated_functions">Calling replicated functions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://wiki.beyondunreal.com/edit/Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask)?section=12" title="Edit section: Calling replicated functions">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>If a replicated function is called and its replication condition is met, the call and all parameter values passed to it will be sent to the remote side immediately. If the condition isn't met, the function will be called locally instead. That means, if the executing actor does not have any <i>Owner</i> or the owner does not belong to any clients, the function call is evaluated as if the function isn't defined to be replicated. For functions replicated from a client to the server this usually means the function call is ignored because it lacks the <b>simulated</b> keyword. Calls from the server that stay on the server don't have such a "failsafe switch" and will cause the function to be executed there.</p>
<p>Note that while replicated functions are allowed to have a return type, the actual return value will be that type's null value if the function is replicated successfully. The code will not wait for the function to be executed and return a value, that's just not feasible for a game engine. If you want a replicated function to send by a value, you need to do that via a parameter of another replicated function that is sent in the other direction. Similarly if a replicated function has <a href="Out.html" title="Out" class="mw-redirect">out</a> parameters, their value will not change if the function is replicated. On the remote side, any out parameters or return values will be discarded when the function has finished.</p>
<p>Note that the parameters of replicated functions are subject to the same variable compression strategies as mentioned in the section about variable replication. Additionally, any parameter that is a null value is omitted from the replication data to save bandwidth. This goes only for entire parameter values, not for individual members of a struct used as a parameter type.</p>
<h3><span class="mw-headline" id="Reliability">Reliability</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://wiki.beyondunreal.com/edit/Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask)?section=13" title="Edit section: Reliability">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Function call replication can be either "reliable" or "unreliable", which is specified by the keywords of the same name either in the replication condition in UE1/2 or as optional function modifier in UE3. If a function is marked as "reliable", the engine makes sure it is processed in the correct order in relation to other reliable network events, especially other reliable function calls. But also opening and closing an actor channel is a reliable event. In other words, provided they are called after the actor channel is opened by the server, reliably replicated function calls are guaranteed to be processed on the client while the actor exists and they are guaranteed top be processed in the same order as they were called on the server.</p>
<p>Why is the order important? I'll spare you the gory details, but we need to get a bit more technical to answer that. The Unreal Engine uses <a href="http://en.wikipedia.org/wiki/User_Datagram_Protocol" class="extiw" title="wp:User Datagram Protocol">UDP</a> to transmit its data. This protocol does not actually create a connection, but just sends packets to the target address. It doesn't even guarantee that the packets arrive, let alone that they arrive in the same order they were sent. Due to the way the internet works, different packets might takes different routes and overtake each other. They may get dropped somewhere or even get duplicated.</p>
<p>Sounds like a nightmare, but the lack of checks also has a big advantage. The <a href="http://en.wikipedia.org/wiki/Transmission_Control_Protocol" class="extiw" title="wp:Transmission Control Protocol">TCP</a> protocol would implement guaranteed order and data integrity, but all of its checks cause a lot of overhead and slow down transfers. That might not be a problem for file transfers (HTTP, FTP and the various mail protocols are built on TCP), but for a game where low response times are crucial, this would be a catastrophe. Thus the engine swallows the bitter pill and performs its own checks for dropped, duplicated and out-of-order packets. These checks are only performed for important things like opening/closing actor channel or reliable replicated function calls. Note that even reliable function calls might get lost when there's packet loss, but the calls that do arrive are guaranteed to be executed in the correct order.</p>
<p>Unreliable function calls on the other hand might not even get send if the connection is saturated. If they are sent, they are more likely to get lost, they could be duplicated or be called out of the correct order. If the ordering gets really bad, they may even arrive after their channel is already closed or before it was opened on the client, in which case they are dropped. In stock code, unreliable functions are used for things like replicating sounds, less important visual effects and (this may be surprising) player input. If one player input packet is lost, this usually isn't a great problem as the server extrapolates movement and the client has some freedom in correcting the server's extrapolation errors. Losing a jump or fire event may be a bit annoying, but the sheer amount of input packets causes unreliable replication to provide a huge advantage compared to reliable replication, including better response times. Duplicated and out-of-order packets are caught by a timestamp value in the function call, which allows the server to discard any obsolete updates.</p>
<p>So when deciding whether to make a function reliable or unreliable ask yourself the following questions: Is it really that bad if the function call gets lost underway or isn't received in the correct order? And if so, would the advantages of making it reliable outweigh the response time penalty caused by the engine ensuring the correct order?</p>
<h2><span class="mw-headline" id="Ok.2C_what.27s_with_that_.22simulated.22_keyword.3F">Ok, what's with that "simulated" keyword?</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="https://wiki.beyondunreal.com/edit/Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask)?section=14" title="Edit section: Ok, what's with that &quot;simulated&quot; keyword?">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Ah yes, that weird function modifier. In fact, it can also be applied to <a href="States.html" title="States">states</a> to affect state code in the same way. Remember the talk about <i>Role</i> and <i>RemoteRole</i> and how they are exchanged on the client up in the first few sections of this article? Well, the <b>simulated</b> keyword, or actually the lack of it, is related to the value of the <i>Role</i> property. Actor instances (as opposed to static functions and non-actor objects) will execute code in their functions and states only if the actor's <i>Role</i> is higher than <code>ROLE_SimulatedProxy</code> or if the function or state is marked as <b>simulated</b> (or (<b>native</b>).</p>
<p>Offline and on a server all actors have <code>ROLE_Authority</code> as their <i>Role</i> value, and the same goes for "runtime actors" (remember? <i>bStatic</i> and <i>bNoDelete</i> both set to False) created on the client via the <i>Spawn()</i> function, i.e. not received through replication. Also <i>bStatic</i> or <i>bNoDelete</i> actors that are <i>bClientAuthoritative</i> don't get their roles exchanged on clients, and replicated actors that are "torn off" get their roles exchanged back to the original values, so these also have a <i>Role</i> of <code>ROLE_Authority</code> on the client.</p>
<p>Now the rule says "either simulated or <i>Role</i> higher than <code>ROLE_SimulatedProxy</code>", but <code>ROLE_Authority</code> is not the only role satisfying that rule. There's also <code>ROLE_AutonomousProxy</code>, which is used by the local PlayerController and its Pawn on the client. That is actually set as the <i>RemoteRole</i> value on the server, but replication magic downgrades it to <code>ROLE_SimulatedProxy</code> on other clients so it really only applies to the owning client.</p>
<p>On the other side, there are also <code>ROLE_DumbProxy</code> (at least in UE1/2) and <code>ROLE_None</code>. Remember how mapper-placed actors may end up with <i>Role</i> set to <code>ROLE_None</code> on clients? It just means you can't use replication on them, but nothing would prevent you from calling simulated functions on these actors, if they had any.</p>

<!-- 
NewPP limit report
CPU time usage: 0.085 seconds
Real time usage: 0.089 seconds
Preprocessor visited node count: 64/1000000
Preprocessor generated node count: 80/1000000
Post‐expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
-->

<!-- 
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 - -total
-->

<!-- Saved in parser cache with key wiki:pcache:idhash:29127-0!*!0!!en!5!* and timestamp 20161216053430 and revision id 45930
 -->
</div><div class="printfooter">
Retrieved from "<a dir="ltr" href="https://wiki.beyondunreal.com/Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask)?oldid=45930">https://wiki.beyondunreal.com/Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask)?oldid=45930</a>"</div>
					<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="https://wiki.beyondunreal.com/Special:Categories" title="Special:Categories">Categories</a>: <ul><li><a href="Category_Programming_articles.html" title="Category:Programming articles">Programming articles</a></li><li><a href="Category_Replication.html" title="Category:Replication">Replication</a></li></ul></div></div>					<!-- end content -->
										<div class="visualClear"></div>
				</div>
			</div>
		</div>
		<div id="column-one">
			<h2>Navigation menu</h2>
					<div id="p-cactions" class="portlet" role="navigation">
			<h3>Views</h3>

			<div class="pBody">
				<ul>
				<li id="ca-nstab-main" class="selected"><a href="Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask).html" title="View the content page [c]" accesskey="c">Page</a></li>
				<li id="ca-talk"><a href="Talk_Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask).html" title="Discussion about the content page [t]" accesskey="t">Discussion</a></li>
				<li id="ca-edit"><a href="https://wiki.beyondunreal.com/edit/Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask)" title="You can edit this page. Please use the preview button before saving [e]" accesskey="e">Edit</a></li>
				<li id="ca-history"><a href="https://wiki.beyondunreal.com/history/Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask)" title="Past revisions of this page [h]" accesskey="h">History</a></li>
				</ul>
							</div>
		</div>
				<div class="portlet" id="p-personal" role="navigation">
				<h3>Personal tools</h3>

				<div class="pBody">
					<ul>
													<li id="pt-createaccount"><a href="https://wiki.beyondunreal.com/Special:UserLogin?returnto=Everything+you+ever+wanted+to+know+about+replication+%28but+were+afraid+to+ask%29&amp;type=signup" title="You are encouraged to create an account and log in; however, it is not mandatory">Create account</a></li>
													<li id="pt-login"><a href="https://wiki.beyondunreal.com/Special:UserLogin?returnto=Everything+you+ever+wanted+to+know+about+replication+%28but+were+afraid+to+ask%29" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>
											</ul>
				</div>
			</div>
			<div class="portlet" id="p-logo" role="banner">
				<a href="index.html" class="mw-wiki-logo" title="Visit the main page"></a>
			</div>
				<div class="generated-sidebar portlet" id="p-navigation" role="navigation">
		<h3>Navigation</h3>
		<div class='pBody'>
							<ul>
											<li id="n-mainpage"><a href="index.html" title="Visit the main page [z]" accesskey="z">Main Page</a></li>
											<li id="n-portal"><a href="Unreal_Wiki_Community_portal-2.html" title="About the project, what you can do, where to find things">Community portal</a></li>
											<li id="n-recentchanges"><a href="https://wiki.beyondunreal.com/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li>
											<li id="n-randompage"><a href="https://wiki.beyondunreal.com/Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li>
											<li id="n-help"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>
											<li id="n-Forums-.28General.29"><a href="https://forums.beyondunreal.com/forums/wiki-general.250/" rel="nofollow">Forums (General)</a></li>
											<li id="n-Forums-.28Technical.29"><a href="https://forums.beyondunreal.com/forums/wiki-technical.251/" rel="nofollow">Forums (Technical)</a></li>
									</ul>
					</div>
		</div>
			<div id="p-search" class="portlet" role="search">
			<h3><label for="searchInput">Search</label></h3>

			<div id="searchBody" class="pBody">
				<form action="https://wiki.beyondunreal.com/" id="searchform">
					<input type='hidden' name="title" value="Special:Search"/>
					<input type="search" name="search" placeholder="Search" title="Search Unreal Wiki [f]" accesskey="f" id="searchInput" />
					<input type="submit" name="go" value="Go" title="Go to a page with this exact name if exists" id="searchGoButton" class="searchButton" />&#160;
						<input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton" />
				</form>

							</div>
		</div>
			<div class="portlet" id="p-tb" role="navigation">
			<h3>Tools</h3>

			<div class="pBody">
				<ul>
											<li id="t-whatlinkshere"><a href="https://wiki.beyondunreal.com/Special:WhatLinksHere/Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask)" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li>
											<li id="t-recentchangeslinked"><a href="https://wiki.beyondunreal.com/Special:RecentChangesLinked/Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask)" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li>
											<li id="t-specialpages"><a href="https://wiki.beyondunreal.com/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li>
											<li id="t-print"><a href="https://wiki.beyondunreal.com/Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask)?printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li>
											<li id="t-permalink"><a href="https://wiki.beyondunreal.com/Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask)?oldid=45930" title="Permanent link to this revision of the page">Permanent link</a></li>
											<li id="t-info"><a href="https://wiki.beyondunreal.com/info/Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask)" title="More information about this page">Page information</a></li>
									</ul>
							</div>
		</div>
			</div><!-- end of the left (by default at least) column -->
		<div class="visualClear"></div>
					<div id="footer" role="contentinfo">
						<div id="f-copyrightico">
									<a href="https://creativecommons.org/licenses/by-nc-sa/3.0/"><img src="../licensebuttons.net/l/by-nc-sa/3.0/88x31.png" alt="Attribution-Noncommercial-Share Alike 3.0" width="88" height="31" /></a>
							</div>
					<div id="f-poweredbyico">
									<script async src="../pagead2.googlesyndication.com/pagead/js/f.txt"></script>
        <!-- Home Page -->
        <ins class="adsbygoogle"
             style="display:inline-block;width:728px;height:90px"
             data-ad-client="ca-pub-9605963037553244"
             data-ad-slot="9528541415"></ins>
        <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
							</div>
					<ul id="f-list">
									<li id="lastmod"> Last modified at 07:25, 19 January 2014.</li>
									<li id="copyright">Licensed as <a href="Unreal_Wiki_Copyrights.html" title="Unreal Wiki:Copyrights">Attribution-Noncommercial-Share Alike 3.0</a>.</li>
									<li id="privacy"><a href="Unreal_Wiki_Privacy_policy.html" title="Unreal Wiki:Privacy policy">Privacy policy</a></li>
									<li id="about"><a href="Unreal_Wiki_About.html" title="Unreal Wiki:About">About Unreal Wiki</a></li>
									<li id="disclaimer"><a href="Unreal_Wiki_General_disclaimer.html" title="Unreal Wiki:General disclaimer">Disclaimers</a></li>
							</ul>
		</div>
		</div>
		<script>if(window.jQuery)jQuery.ready();</script><script>if(window.mw){
mw.loader.state({"site":"loading","user":"ready","user.groups":"ready"});
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.toc","mediawiki.action.view.postEdit","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.searchSuggest"],null,true);
}</script>
<script>if(window.mw){
document.write("\u003Cscript src=\"https://wiki.beyondunreal.com/w/load.php?debug=false\u0026amp;lang=en\u0026amp;modules=site\u0026amp;only=scripts\u0026amp;skin=monobook\u0026amp;*\"\u003E\u003C/script\u003E");
}</script>
<script>if(window.mw){
mw.config.set({"wgBackendResponseTime":113});
}</script></body>
<!-- Mirrored from wiki.beyondunreal.com/Everything_you_ever_wanted_to_know_about_replication_(but_were_afraid_to_ask) by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 16 Dec 2016 07:52:50 GMT -->
</html>
